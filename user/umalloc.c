#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/param.h"
// Memory allocator by Kernighan and Ritchie,
// The C programming Language, 2nd ed.  Section 8.7.

#define NALLOC 4096  // ????????,?? sbrk ???
#ifdef NULL
#undef NULL
#endif
#define NULL 0

// ?? long ?????????????
typedef long Align;

/* ?? Header ????????? kandr_malloc ???????
 * ??????????????,?????? header ?????,
 * ?? header ???????????????????????;
 * ????????,?????????,????????????
 * ????????????,???? Align ?????(??????????),
 * ?????? Header ??????????????Align ???????;
 * ?????? header ?????????
 */
union header {
  struct {
    union header *next;
    unsigned size;
  } s;

  Align x;
};
typedef union header Header;

static Header base;           // ?????????????, ?????
static Header *freep = NULL;  // ????????

static Header *morecore(unsigned nblocks);
void free(void *ptr);

void *malloc(unsigned nbytes) {

  Header *currp;
  Header *prevp;
  unsigned nunits;

  /* ?????? nbytes ???????????
   *
   * ?????? n >= 0 ??,??????? b > 0 ???
   * ? n / b(????)???? n ????????????,
   * ?? n ? b ???;??????????????
   * ????,(n - 1)/ b ??? n ??????????????,??? n > 0 ????
   * ?? ((n - 1) / b) + 1 ???????????,? n > 0 ??
   *
   * ???? sizeof(Header) ??????? header ??????????
   */
  nunits = ((nbytes + sizeof(Header) - 1) / sizeof(Header)) + 1; /* 1.???? sizeof(Header) */

  // ??: ????????;?????????
  if (freep == NULL) {

    // ?????????;base ????????? 0
    base.s.next = &base;
    base.s.size = 0;

    // ??????????? base ??
    freep = &base;
  }

  /* ?????????????????,?????? prevp(????)? currp(???)
   */
  prevp = freep;
  currp = prevp->s.next;

  /* ????????,?????????????? nunits ??????
   * ?????????????????,??? morecore ????????????
   */
  for (; ; prevp = currp, currp = currp->s.next) {

    /* ??: ???????????????????? nunits ??????
     * ??????,?????????????,??????(? header ??)?
     */
    if (currp->s.size >= nunits) {

      /* ??: ????????;?????????????????????????
       */
      if (currp->s.size == nunits) {
        /* ???,??????????,???????????????
         * ??,??????????????,?????(&base)???? 0,
         * ?????(???,nunits ?? >= 1)?
         * ??,????????????,????????? - 
         * ?????????????,??????????,???????????????
         */
        prevp->s.next = currp->s.next;
      }
      /* ??: ?????????????;?????????????
       */
      else {
        // ?? currp ??????????????
        currp->s.size -= nunits;
        // ??????? header ???
        currp += currp->s.size;
        // ??????????
        currp->s.size = nunits;
      }

      /* ???????????????????? malloc ?
       * ?????????????,?????????????,
       * ????????????
       */
      freep = prevp;

      /* ?????????,????????,?? header
       */
      return (void *) (currp + 1);

    } // ???????????????

    /* ??: ??????????,??????????
     * ??? nunits ???????? morecore ?????? nunits ??????
     */
    if (currp == freep) {
      /* morecore ?? freep;???????? currp ?????(??????????????),
       * ??? morecore ??????? free ???????? freep ???
       * ?????????????(currp == freep)????????????
       */
      if ((currp = morecore(nunits)) == NULL) {
        return NULL;
      }
    } // ??????????
  } // ???????????????
}

static Header *morecore(unsigned nunits) {

  void *freemem;    // ????????
  Header *insertp;  // ??????????????

  /* ?????????????????,?????? NALLOC ??????????
   */
  if (nunits < NALLOC) {
    nunits = NALLOC;
  }

  /* ????????????????sbrk ?????????,
   * ??????????????(?,???????????????
   * ??????)?????????????????????
   * ???,brk ??????? - ???????,???????????????
   */
  freemem = sbrk(nunits * sizeof(Header));
  // ??: ????????;sbrk ?????? (void *) -1
  if (freemem == (void *) -1) {
    return NULL;
  }

  // ????
  insertp = (Header *) freemem;
  insertp->s.size = nunits;

  /* ????????,?? malloc ?????
   * ???,?????? 1,??????????????????,
   * ???????????? malloc ? free ??????
   */
  free((void *) (insertp + 1));

  /* ???????????;???,freep ????
   * ?????????(?? free ??)?
   * ?????????,?????????????,????????????
   */
  return freep;
}

void free(void *ptr) {

  Header *insertp, *currp;

  // ?????????????
  insertp = ((Header *) ptr) - 1;

  /* ?????????????????
   * ???????,??????????;
   * ??????????????????????????????????????
   * ?????????????,??????????
   * ?????????????? malloc ???????????(???????),
   * ??? malloc ?????????(??????)?
   * ????????????????????
   */
  for (currp = freep; !((currp < insertp) && (insertp < currp->s.next)); currp = currp->s.next) {

    /* currp >= currp->s.ptr ?????????????????
     * ???????????,?????????;
     * ?????? currp ????(????????)???,
     * ???????????????,???????????????
     * ????????(??????????????????? >= ????? >)?
     */
    if ((currp >= currp->s.next) && ((currp < insertp) || (insertp < currp->s.next))) {
      break;
    }
  }

  /* ????????????????????,??????
   * (i) ?????????,(ii) ??????????
   * ??????? if/else ?????
   */

  /* ??: ??????? malloc ???????????????
   * ?????????????(?,??????????????)?
   */
  if ((insertp + insertp->s.size) == currp->s.next) {
    insertp->s.size += currp->s.next->s.size;
    insertp->s.next = currp->s.next->s.next;
  }
  /* ??: ???? malloc ????????????????
   * ????????????????????
   */
  else {
    insertp->s.next = currp->s.next;
  }

  /* ??: malloc ??????????????????????
   * ?????????????(?,????????????)?
   */
  if ((currp + currp->s.size) == insertp) {
    currp->s.size += insertp->s.size;
    currp->s.next = insertp->s.next;
  }
  /* ??: ???? malloc ????????????????
   * ????????????????
   */
  else {
    currp->s.next = insertp;
  }

  /* ??????????????????
   * ?????,?? malloc ??? freep ?????????????,
   * ???????????????????,???????????????
   * ??? kandr_malloc ??? morecore ??????,
   * ???????????????????????
   */
  freep = currp;
}

#define FRAGMENT_THRESHOLD 1024

void get_memory_fragments() {
  unsigned fragment_count = 0; // ??????
  unsigned total_fragments_size = 0; // ???????

  if (freep == NULL) {
    printf("No free memory blocks available.\n");
    return;
  }

  Header *p = freep;

  // ??????,????????????????
  do {
    if (p->s.size <= FRAGMENT_THRESHOLD / sizeof(Header)) {
      fragment_count++;
      total_fragments_size += p->s.size * sizeof(Header);
    }
    p = p->s.next;
  } while (p != freep);

  // ??????
  printf("Number of fragments <= %d B: %d\n", FRAGMENT_THRESHOLD, fragment_count);
  printf("Total fragments size <= %d B: %d B\n", FRAGMENT_THRESHOLD, total_fragments_size);
}


